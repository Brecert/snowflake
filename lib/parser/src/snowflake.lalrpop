//
// parser - snowflake's parser
//
// copyright (c) 2020 the snowflake authors <whiskerdev@protonmail.com>
// this source code form is subject to the terms of the mozilla public
// license, v. 2.0. if a copy of the mpl was not distributed with this
// file, you can obtain one at http://mozilla.org/MPL/2.0/.
//

// note(@bree): no decendents of ast should be "use"d
// to preserve a visual separation between parsing and ast  
use crate::ast;
use crate::token::Token;
use num_bigint::BigInt;

grammar;

pub Program: Vec<ast::Statement> = {
    ProgramLine* => <>.into_iter().flatten().collect()
}

pub ProgramLine: Vec<ast::Statement> = {
    <s:Statement> "\n" => vec![s],
    "\n" => vec![]
}

// Begin Types
pub TypeStatement: ast::Statement = {
    TypeDecl
}

pub TypeDecl: ast::Statement = {
    <name:Identifier> "::" <expr:TypeExpression> => ast::Statement::TypeDecl {
        name: name,
        body: expr
    }
}

pub TypeExpression: ast::Type = {
    SubTypeExpression,
    FnSig,
}

pub SubTypeExpression: ast::Type = {
    "(" <e:TypeExpression> ")" => e,
    TypeLiteral
}

pub FnSig: ast::Type = {
    <args:SubTypeExpression+> "->" <ret:TypeExpression> => {
        let mut out_args = vec![];
        for arg in args {
            out_args.push(Box::new(arg))
        };
        ast::Type::FnSig {
            args: out_args,
            ret: Box::new(ret)
        }
    }
}

pub TypeLiteral: ast::Type = {
    Integer => ast::Type::Nat(<>),
    Identifier => ast::Type::Identifier(<>),
}
// End Types

pub Statement: ast::Statement = {
    TypeStatement,
    FnDecl,
    // Expression => ast::Statement::Expression(<>)
}

pub FnDecl: ast::Statement = {
    <name:Identifier> <args:Identifier*> "=>" <body:Block> => ast::Statement::FnDecl {
        name: name,
        args: args,
        body: body
    }
}

// (Main)Expression and SubExpression are a solution to remove abiguity issues with FnCall
// for exampe: "add a b" could be seen as able to be parsed multiple ways { add(a, b) or add(a(b)) }
// what this means is that FnCall can't directly have another FnCall in it without some other enclosure.
pub Expression: ast::Expression = {
    SubExpression,
    FnCall,
}

pub SubExpression: ast::Expression = {
    OpCall,
}

pub Block: Vec<Box<ast::Statement>> = {
    <s:ExpressionStatement> => vec![s],
    "\n" Indent <s:ExpressionStatement+> Dedent => s
}

pub ExpressionStatement: Box<ast::Statement> = {
    <e:Expression> "\n" => Box::new(ast::Statement::Expression(e))
}

pub OpCall: ast::Expression = {
    <l:Atom> <op:Op> <r:OpCall> => ast::Expression::OpCall {
        op: op,
        args: vec![
            Box::new(l),
            Box::new(r),
        ]
    },
    Atom
}

// note(@bree): possibly future use, may remove.
pub Atom: ast::Expression = {
    "(" <e:Expression> ")" => e,
    Literal,
}

// FnCall has a rather ambiguous grammar
// any change to the grammer has a possibility of conflicting with FnCall
pub FnCall: ast::Expression = {
    <name:Identifier> <args:SubExpression+> => ast::Expression::FnCall {
        name: name,
        args: args
    }
}

pub Op: ast::OpSymbol = {
  "+" => ast::OpSymbol::Plus,
  "-" => ast::OpSymbol::Minus,
  "*" => ast::OpSymbol::Star,
  "/" => ast::OpSymbol::ForwardSlash
}

pub Literal: ast::Expression = {
  Integer => ast::Expression::Integer(<>),
  Identifier => ast::Expression::Identifier(<>)
}

pub Integer: BigInt = {
  "Integer"
}

pub Identifier: String = {
  "Identifier"
}

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        "Identifier" => Token::Identifier(<String>),
        "Float" => Token::Float(<f64>),
        "Integer" => Token::Integer(<BigInt>),
        "=" => Token::Equal,
        "::" => Token::ColonColon,
        "**" => Token::StarStar,
        "=>" => Token::LargeArrowRight,
        "->" => Token::SmallArrowRight,
        "Whitespace" => Token::Whitespace,
        "Symbol" => Token::Symbol(<char>),
        "Unknown" => Token::Unknown,
        // indentation
        Indent => Token::Indent,
        Dedent => Token::Dedent,
        "\n" => Token::Newline,
        // symbols
        "(" => Token::Symbol('('),
        ")" => Token::Symbol(')'),
        "+" => Token::Symbol('+'),
        "-" => Token::Symbol('-'),
        "*" => Token::Symbol('*'),
        "/" => Token::Symbol('/')
    }
}
